## 1.策略模式

策略模式（Strategy Pattern）是一种行为型设计模式，用于定义一系列算法，将每个算法封装起来，并使它们可互换。策略模式使算法独立于使用它们的客户端而变化。在策略模式中，一个类的行为或算法可以在运行时更改。

## 优点和缺点

策略模式的优点有：

- 可以在运行时动态更改对象的行为。
- 可以将算法的实现与使用算法的客户端代码分离开来，从而使它们彼此独立。
- 可以方便地添加新的算法，只需要实现新的具体策略类即可，不需要修改客户端代码。

策略模式的缺点有：

- 客户端需要了解所有的具体策略类，并在运行时选择适当的算法。如果具体策略类较多，这可能会增加客户端的复杂度。

- 由于策略模式要求每个具体策略类都实现一个接口，因此会增加代码的抽象程度。

总的来说，策略模式适用于需要在运行时动态更改对象的行为的场景，尤其是当具有多种相似的算法时。它可以使得算法的实现与使用算法的客户端代码分离开来，从而使得它们更加独立和易于维护。



## 2.代理模式

代理模式是一种结构型设计模式，其目的是为其他对象提供一种代理以控制对原对象的访问。代理类充当客户端与原始对象之间的中介，它可以拦截对原始对象的访问并执行某些附加操作，例如对原始对象进行缓存或记录访问日志。

### 优点和缺点

优点：

- 代理模式可以在客户端和实际对象之间提供一个中介，从而降低系统的耦合度。
- 代理模式可以为实际对象提供附加功能，例如缓存、记录访问日志等。

缺点：

- 代理模式可能会增加系统的复杂性。
- 代理模式可能会导致系统的性能下降。

在Java中，代理模式可以通过以下两种方式来实现：

- 静态代理：在编译时就已经确定了代理对象和实际对象，代理对象在编译时就已经存在。
- 动态代理：在运行时根据需要动态创建代理对象，代理对象在运行时才会存在。

在实现代理模式时，我们需要根据具体的需求来选择使用哪种代理方式。如果代理对象和实际对象的数量比较少，并且它们在编译时已经确定，那么静态代理是一个不错的选择。但是，如果代理对象和实际对象的数量比较多，或者它们在运行时才能确定，那么动态代理则是更好的选择。



## 3.单例模式

单例模式是一种创建型模式，它确保某个类只有一个实例，并提供了一个全局访问点。

实现单例模式的关键在于，要防止多个线程同时访问同一个对象并创建多个实例。常见的单例模式实现方式有两种：

1. 懒汉式：在首次调用时才创建对象实例。
2. 饿汉式：在类加载时就创建对象实例。

### 优点和缺点

优点：

- 确保了类只有一个实例，并提供了全局的访问点。
- 对象的创建和销毁只会发生一次，节省了系统资源。
- 避免了多个实例之间的数据同步问题，避免了由此产生的错误。

缺点：

- 单例类的职责通常过于集中，容易引起内聚性问题。
- 单例类的扩展性和可测试性较差，因为单例类不能很好地与其他类解耦。
- 单例类如果设计不当，可能会引起全局状态的问题。

### 总结：

单例模式是一种常见的设计模式，它可以确保某个类只有一个实例，并提供了一个全局访问点。但是，单例模式也有其缺点，例如过度集中的职责、扩展性和可测试性差等问题。在应用单例模式时，我们需要根据具体的情况来权衡其优缺点，以确保应用单例模式的合适性。


## 4.工厂方法模式

工厂方法模式（Factory Method Pattern）是一种创建型设计模式，它定义了一个用于创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化延迟到子类中进行。

### 优点和缺点

通过工厂方法，客户端代码与具体产品类解耦，客户端代码只需要知道产品的抽象接口即可，无需关心产品的具体实现。
工厂方法可以在不修改现有客户端代码的情况下，增加新的产品类。
工厂方法可以将产品对象的创建延迟到子类中进行，这样可以更好地符合开闭原则。
工厂方法模式的缺点包括：

工厂方法需要定义一个接口或抽象类来表示工厂，这会增加系统的抽象性和理解难度。
工厂方法模式可能会导致系统中类的数量增加，增加代码复杂度

